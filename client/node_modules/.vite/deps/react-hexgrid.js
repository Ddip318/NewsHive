import {
  require_jsx_runtime
} from "./chunk-XREXF2BJ.js";
import {
  __commonJS,
  __toESM,
  require_react
} from "./chunk-QH6HOCAD.js";

// node_modules/classnames/index.js
var require_classnames = __commonJS({
  "node_modules/classnames/index.js"(exports, module) {
    (function() {
      "use strict";
      var hasOwn = {}.hasOwnProperty;
      function classNames2() {
        var classes = "";
        for (var i = 0; i < arguments.length; i++) {
          var arg = arguments[i];
          if (arg) {
            classes = appendClass(classes, parseValue(arg));
          }
        }
        return classes;
      }
      function parseValue(arg) {
        if (typeof arg === "string" || typeof arg === "number") {
          return arg;
        }
        if (typeof arg !== "object") {
          return "";
        }
        if (Array.isArray(arg)) {
          return classNames2.apply(null, arg);
        }
        if (arg.toString !== Object.prototype.toString && !arg.toString.toString().includes("[native code]")) {
          return arg.toString();
        }
        var classes = "";
        for (var key in arg) {
          if (hasOwn.call(arg, key) && arg[key]) {
            classes = appendClass(classes, key);
          }
        }
        return classes;
      }
      function appendClass(value, newClass) {
        if (!newClass) {
          return value;
        }
        if (value) {
          return value + " " + newClass;
        }
        return value + newClass;
      }
      if (typeof module !== "undefined" && module.exports) {
        classNames2.default = classNames2;
        module.exports = classNames2;
      } else if (typeof define === "function" && typeof define.amd === "object" && define.amd) {
        define("classnames", [], function() {
          return classNames2;
        });
      } else {
        window.classNames = classNames2;
      }
    })();
  }
});

// node_modules/react-hexgrid/lib/models/Hex.js
var Hex = class {
  constructor(q, r, s) {
    this.q = q;
    this.r = r;
    this.s = s;
  }
};

// node_modules/react-hexgrid/lib/models/Point.js
var Point = class {
  constructor(x, y) {
    this.x = x;
    this.y = y;
  }
};
var Point_default = Point;

// node_modules/react-hexgrid/lib/HexUtils.js
var HexUtils = class _HexUtils {
  /** Checks if coordinates are the same.*/
  static equals(a, b) {
    return a.q == b.q && a.r == b.r && a.s == b.s;
  }
  /** Returns a new Hex with the addition of q,r,s values from A and B respectively */
  static add(a, b) {
    return new Hex(a.q + b.q, a.r + b.r, a.s + b.s);
  }
  /** Returns a new Hex with the subtraction of q,r,s values from A and B respectively */
  static subtract(a, b) {
    return new Hex(a.q - b.q, a.r - b.r, a.s - b.s);
  }
  /** Returns a new Hex with the multiplication of q,r,s values by k */
  static multiply(a, k) {
    return new Hex(a.q * k, a.r * k, a.s * k);
  }
  /** Returns length from origin point 0,0 */
  static lengths(hex) {
    return (Math.abs(hex.q) + Math.abs(hex.r) + Math.abs(hex.s)) / 2;
  }
  /** Returns the distance between two hex coordinates */
  static distance(a, b) {
    return _HexUtils.lengths(_HexUtils.subtract(a, b));
  }
  /** Returns a new Hex in the "direction", which has modulus six, "% 6", applied to it,
   * and thus computes to a number between 0 through 5. */
  static direction(direction) {
    return _HexUtils.DIRECTIONS[(6 + direction % 6) % 6];
  }
  /** Returns the addition of the current Hex and a new Hex in the
   * specified "direction". Direction has modulus six, "% 6", applied to it,
   * and thus computes to a number between 0 through 5.
   */
  static neighbor(hex, direction) {
    return _HexUtils.add(hex, _HexUtils.direction(direction));
  }
  /** Returns an array of all the direct neighbors of a Hex within one Hex away */
  static neighbors(hex) {
    const array = [];
    for (let i = 0; i < _HexUtils.DIRECTIONS.length; i += 1) {
      array.push(_HexUtils.neighbor(hex, i));
    }
    return array;
  }
  /** I'm not sure what this does */
  static round(hex) {
    let rq = Math.round(hex.q);
    let rr = Math.round(hex.r);
    let rs = Math.round(hex.s);
    const qDiff = Math.abs(rq - hex.q);
    const rDiff = Math.abs(rr - hex.r);
    const sDiff = Math.abs(rs - hex.s);
    if (qDiff > rDiff && qDiff > sDiff)
      rq = -rr - rs;
    else if (rDiff > sDiff)
      rr = -rq - rs;
    else
      rs = -rq - rr;
    return new Hex(rq, rr, rs);
  }
  /** Given the q,r,s of a hexagon return the x and y pixel coordinates of the
   * hexagon center. */
  static hexToPixel(hex, layout) {
    const s = layout.spacing;
    const M = layout.orientation;
    let x = (M.f0 * hex.q + M.f1 * hex.r) * layout.size.x;
    let y = (M.f2 * hex.q + M.f3 * hex.r) * layout.size.y;
    x = x * s;
    y = y * s;
    return new Point(x + layout.origin.x, y + layout.origin.y);
  }
  /** Return the q,r,s coordinate of the hexagon given pixel point x and y. */
  static pixelToHex(point, layout) {
    const M = layout.orientation;
    const pt = new Point((point.x - layout.origin.x) / layout.size.x, (point.y - layout.origin.y) / layout.size.y);
    const q = M.b0 * pt.x + M.b1 * pt.y;
    const r = M.b2 * pt.x + M.b3 * pt.y;
    const hex = new Hex(q, r, -q - r);
    return _HexUtils.round(hex);
  }
  /** Apply Linear Interpolation between two known points
   * See:
   * https://en.wikipedia.org/wiki/Linear_interpolation
   */
  static lerp(a, b, t) {
    return a + (b - a) * t;
  }
  /** Apply Linear Interpolation between two known Hexes
   * See:
   * https://en.wikipedia.org/wiki/Linear_interpolation
   */
  static hexLerp(a, b, t) {
    return new Hex(_HexUtils.lerp(a.q, b.q, t), _HexUtils.lerp(a.r, b.r, t), _HexUtils.lerp(a.s, b.s, t));
  }
  /** Return a string ID from Hex Coordinates.
   * Example: Hex Coordinates of {q: 1, r: 2, s: 3} is returned
   * as string "1,2,3"
   */
  static getID(hex) {
    return `${hex.q},${hex.r},${hex.s}`;
  }
};
HexUtils.DIRECTIONS = [
  new Hex(1, 0, -1),
  new Hex(1, -1, 0),
  new Hex(0, -1, 1),
  new Hex(-1, 0, 1),
  new Hex(-1, 1, 0),
  new Hex(0, 1, -1)
];

// node_modules/react-hexgrid/lib/GridGenerator.js
var GridGenerator = class _GridGenerator {
  /** This method is used to dynamically choose a type of grid to
   * generate.
   */
  static getGenerator(name) {
    const x = _GridGenerator[name];
    return x;
  }
  /** May not be working. There are no tests for it. */
  static ring(center, mapRadius) {
    let hexas = [];
    let hex = HexUtils.add(center, HexUtils.multiply(HexUtils.direction(4), mapRadius));
    for (let i = 0; i < 6; i++) {
      for (let j = 0; j < mapRadius; j++) {
        hexas.push(hex);
        hex = HexUtils.neighbor(hex, i);
      }
    }
    return hexas;
  }
  /** May not be working. There are no tests for it. */
  static spiral(center, mapRadius) {
    let results = [center];
    for (let k = 1; k <= mapRadius; k++) {
      const temp = _GridGenerator.ring(center, k);
      results = results.concat(temp);
    }
    return results;
  }
  /** Returns an array of Hex coordinates needed to create a
   * parallelogram grid */
  static parallelogram(q1, q2, r1, r2) {
    let hexas = [];
    for (let q = q1; q <= q2; q++) {
      for (let r = r1; r <= r2; r++) {
        hexas.push(new Hex(q, r, -q - r));
      }
    }
    return hexas;
  }
  /** Returns an array of Hex coordinates needed to create a
   * triangle grid
   */
  static triangle(mapSize) {
    let hexas = [];
    for (let q = 0; q <= mapSize; q++) {
      for (let r = 0; r <= mapSize - q; r++) {
        hexas.push(new Hex(q, r, -q - r));
      }
    }
    return hexas;
  }
  /** Returns an array of Hex coordinates needed to create a
   * Hexagon grid */
  static hexagon(mapRadius) {
    let hexas = [];
    for (let q = -mapRadius; q <= mapRadius; q++) {
      let r1 = Math.max(-mapRadius, -q - mapRadius);
      let r2 = Math.min(mapRadius, -q + mapRadius);
      for (let r = r1; r <= r2; r++) {
        hexas.push(new Hex(q, r, -q - r));
      }
    }
    return hexas;
  }
  /** Returns an array of Hex coordinates needed to create
   * a diagonal rectangle grid */
  static rectangle(mapWidth, mapHeight) {
    let hexas = [];
    for (let r = 0; r < mapHeight; r++) {
      let offset = Math.floor(r / 2);
      for (let q = -offset; q < mapWidth - offset; q++) {
        hexas.push(new Hex(q, r, -q - r));
      }
    }
    return hexas;
  }
  /** Returns an array of Hex coordinates needed to create a vertical
   * and horizontal rectangle.
   */
  static orientedRectangle(mapWidth, mapHeight) {
    let hexas = [];
    for (let q = 0; q < mapWidth; q++) {
      let offset = Math.floor(q / 2);
      for (let r = -offset; r < mapHeight - offset; r++) {
        hexas.push(new Hex(q, r, -q - r));
      }
    }
    return hexas;
  }
};

// node_modules/react-hexgrid/lib/HexGrid.js
var import_jsx_runtime = __toESM(require_jsx_runtime());
var __rest = function(s, e) {
  var t = {};
  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
    t[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
      if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
        t[p[i]] = s[p[i]];
    }
  return t;
};
function HexGrid(_a) {
  var { width = 800, height = 600, viewBox = "-50 -50 100 100" } = _a, props = __rest(_a, ["width", "height", "viewBox"]);
  return (0, import_jsx_runtime.jsx)("svg", Object.assign({ className: "grid", width, height, viewBox, version: "1.1", xmlns: "http://www.w3.org/2000/svg" }, props));
}

// node_modules/react-hexgrid/lib/Layout.js
var import_jsx_runtime2 = __toESM(require_jsx_runtime());
var React = __toESM(require_react());

// node_modules/react-hexgrid/lib/models/Orientation.js
var Orientation = class {
  constructor(f0, f1, f2, f3, b0, b1, b2, b3, startAngle) {
    this.f0 = f0;
    this.f1 = f1;
    this.f2 = f2;
    this.f3 = f3;
    this.b0 = b0;
    this.b1 = b1;
    this.b2 = b2;
    this.b3 = b3;
    this.startAngle = startAngle;
  }
};

// node_modules/react-hexgrid/lib/Layout.js
var __rest2 = function(s, e) {
  var t = {};
  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
    t[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
      if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
        t[p[i]] = s[p[i]];
    }
  return t;
};
var LAYOUT_FLAT = new Orientation(3 / 2, 0, Math.sqrt(3) / 2, Math.sqrt(3), 2 / 3, 0, -1 / 3, Math.sqrt(3) / 3, 0);
var LAYOUT_POINTY = new Orientation(Math.sqrt(3), Math.sqrt(3) / 2, 0, 3 / 2, Math.sqrt(3) / 3, -1 / 3, 0, 2 / 3, 0.5);
var defaultSize = new Point(10, 10);
var defaultOrigin = new Point(0, 0);
var defaultSpacing = 1;
var Context = React.createContext({
  layout: {
    size: defaultSize,
    orientation: LAYOUT_FLAT,
    origin: defaultOrigin,
    spacing: defaultSpacing
  },
  points: ""
});
function useLayoutContext() {
  const ctx = React.useContext(Context);
  return ctx;
}
function calculateCoordinates(circumradius, angle = 0, center = new Point(0, 0)) {
  const corners = [];
  for (let i = 0; i < 6; i++) {
    const x = circumradius.x * Math.cos(2 * Math.PI * i / 6 + angle);
    const y = circumradius.y * Math.sin(2 * Math.PI * i / 6 + angle);
    const point = new Point(center.x + x, center.y + y);
    corners.push(point);
  }
  return corners;
}
function Layout(_a) {
  var { size = defaultSize, flat = true, spacing = defaultSpacing, origin = defaultOrigin, children, className } = _a, rest = __rest2(_a, ["size", "flat", "spacing", "origin", "children", "className"]);
  const orientation = flat ? LAYOUT_FLAT : LAYOUT_POINTY;
  const angle = flat ? 0 : Math.PI / 6;
  const cornerCoords = calculateCoordinates(size, angle);
  const points = cornerCoords.map((point) => `${point.x},${point.y}`).join(" ");
  const childLayout = Object.assign({}, rest, {
    orientation,
    size,
    origin,
    spacing
  });
  return (0, import_jsx_runtime2.jsx)(Context.Provider, Object.assign({ value: {
    layout: childLayout,
    points
  } }, { children: (0, import_jsx_runtime2.jsx)("g", Object.assign({ className }, { children })) }));
}

// node_modules/react-hexgrid/lib/Path.js
var import_jsx_runtime3 = __toESM(require_jsx_runtime());
var __rest3 = function(s, e) {
  var t = {};
  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
    t[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
      if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
        t[p[i]] = s[p[i]];
    }
  return t;
};
function Path(_a) {
  var { start, end } = _a, props = __rest3(_a, ["start", "end"]);
  const { layout } = useLayoutContext();
  function getPoints() {
    if (!start || !end) {
      return "";
    }
    let distance = HexUtils.distance(start, end);
    let intersects = [];
    let step = 1 / Math.max(distance, 1);
    for (let i = 0; i <= distance; i++) {
      intersects.push(HexUtils.round(HexUtils.hexLerp(start, end, step * i)));
    }
    let points = "M";
    points += intersects.map((hex) => {
      let p = HexUtils.hexToPixel(hex, layout);
      return ` ${p.x},${p.y} `;
    }).join("L");
    return points;
  }
  return (0, import_jsx_runtime3.jsx)("path", Object.assign({}, props, { d: getPoints() }));
}

// node_modules/react-hexgrid/lib/Pattern.js
var import_jsx_runtime4 = __toESM(require_jsx_runtime());
var defaultSize2 = new Point_default(10, 10);
function Pattern({ id, link, size = defaultSize2 }) {
  return (0, import_jsx_runtime4.jsx)("defs", { children: (0, import_jsx_runtime4.jsx)("pattern", Object.assign({ id, patternUnits: "objectBoundingBox", x: 0, y: 0, width: size.x, height: size.y }, { children: (0, import_jsx_runtime4.jsx)("image", { xlinkHref: link, x: 0, y: 0, width: size.x * 2, height: size.y * 2 }) })) });
}

// node_modules/react-hexgrid/lib/Hexagon/Hexagon.js
var import_jsx_runtime5 = __toESM(require_jsx_runtime());
var React2 = __toESM(require_react());
var import_classnames = __toESM(require_classnames());
var __rest4 = function(s, e) {
  var t = {};
  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
    t[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
      if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
        t[p[i]] = s[p[i]];
    }
  return t;
};
function Hexagon(props) {
  const { q, r, s, fill, cellStyle, className, children, onDragStart, onDragEnd, onDrop, onDragOver, onMouseEnter, onMouseLeave, onMouseOver, onClick, data, fillOpacity } = props, rest = __rest4(props, ["q", "r", "s", "fill", "cellStyle", "className", "children", "onDragStart", "onDragEnd", "onDrop", "onDragOver", "onMouseEnter", "onMouseLeave", "onMouseOver", "onClick", "data", "fillOpacity"]);
  const { layout, points } = useLayoutContext();
  const { hex, pixel } = React2.useMemo(() => {
    const hex2 = new Hex(q, r, s);
    const pixel2 = HexUtils.hexToPixel(hex2, layout);
    return {
      hex: hex2,
      pixel: pixel2
    };
  }, [q, r, s, layout]);
  const state = { hex };
  const fillId = fill ? `url(#${fill})` : void 0;
  const draggable = { draggable: true };
  return (0, import_jsx_runtime5.jsx)("g", Object.assign({ className: (0, import_classnames.default)("hexagon-group", className), transform: `translate(${pixel.x}, ${pixel.y})` }, rest, draggable, { onDragStart: (e) => {
    if (onDragStart) {
      const targetProps = {
        hex,
        pixel,
        data,
        fill,
        className
      };
      e.dataTransfer.setData("hexagon", JSON.stringify(targetProps));
      onDragStart(e, { data, state, props });
    }
  }, onDragEnd: (e) => {
    if (onDragEnd) {
      e.preventDefault();
      const success = e.dataTransfer.dropEffect !== "none";
      onDragEnd(e, { state, props }, success);
    }
  }, onDrop: (e) => {
    if (onDrop) {
      e.preventDefault();
      const target = JSON.parse(e.dataTransfer.getData("hexagon"));
      onDrop(e, { data, state, props }, target);
    }
  }, onDragOver: (e) => {
    if (onDragOver) {
      onDragOver(e, { data, state, props });
    }
  }, onMouseEnter: (e) => {
    if (onMouseEnter) {
      onMouseEnter(e, { data, state, props });
    }
  }, onClick: (e) => {
    if (onClick) {
      onClick(e, { data, state, props });
    }
  }, onMouseOver: (e) => {
    if (onMouseOver) {
      onMouseOver(e, { data, state, props });
    }
  }, onMouseLeave: (e) => {
    if (onMouseLeave) {
      onMouseLeave(e, { data, state, props });
    }
  } }, { children: (0, import_jsx_runtime5.jsxs)("g", Object.assign({ className: "hexagon" }, { children: [(0, import_jsx_runtime5.jsx)("polygon", { points, fill: fillId, style: cellStyle }), children] })) }));
}

// node_modules/react-hexgrid/lib/Hexagon/Text.js
var import_jsx_runtime6 = __toESM(require_jsx_runtime());
var __rest5 = function(s, e) {
  var t = {};
  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
    t[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
      if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
        t[p[i]] = s[p[i]];
    }
  return t;
};
function Text(props) {
  const { children, x, y } = props, rest = __rest5(props, ["children", "x", "y"]);
  return (0, import_jsx_runtime6.jsx)("text", Object.assign({ x: x || 0, y: y ? y : "0.3em", textAnchor: "middle" }, rest, { children }));
}
export {
  GridGenerator,
  Hex,
  HexGrid,
  HexUtils,
  Hexagon,
  Layout,
  Path,
  Pattern,
  Text
};
/*! Bundled license information:

classnames/index.js:
  (*!
  	Copyright (c) 2018 Jed Watson.
  	Licensed under the MIT License (MIT), see
  	http://jedwatson.github.io/classnames
  *)
*/
//# sourceMappingURL=react-hexgrid.js.map
